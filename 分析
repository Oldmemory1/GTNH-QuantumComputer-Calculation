提前说明，本人的Java水平非常差，我是仿照看C++的方式强硬理解下面的TecTech源码，如果发现有错误，请一定要在评论区指出。

我找到了部分相关的函数和方法和类：见RackComponent.java

经过分析RackComponent为一个类，指代可以放进量子计算机机箱的组件，类中包含该物品非本地化名称，产热（heat），热效率（CoEff），可产生的算力（Computation），可以忍受的最大温度（maxHeat），subZero暂时没看出来代表什么，但是创建的对象的subZero都是true，实际计算也与subZero的的true和false无关。

接下来找到计算算力的方法：见计算算力和产热量.java

注意到，正常运行时，传给getComputationPower的参数tickingComponents是true。

TecTech.RANDOM.nextFloat()方法是取(0,1.0)的随机浮点数。

把代码转化成自然语言就是：超频时间倍数>3或者超频电压倍数>2时，机器会烧掉。

每秒遍历单个机箱里面的所有组件，首先计算机箱改变的热量ΔHeat：

对于单个组件，机箱热量改变量ΔHeat=(1+组件的热效率*（当前热量/10000）)*ψ

Ψ变量与组件是否产热有关

如果组件产热，Ψ=组件产热*[(超频时间倍数)^2]*(超频电压倍数)

如果组件不产热，Ψ=组件产热

实际上，对于散热片一类，组件产热是负值

理论上总热量改变量ΣΔHeat=Σ(i=1,4) (1+热效率(i)*当前热量/10000)*Ψ(i)

实际上，对ΣΔHeat的向上取整值才是真实改变的热量

然后计算算力的提供量：

首先判断超频电压倍数*10和7+σ的大小关系（σ为（0,1.0）之间的随机浮点数）：

如果超频电压倍数*10>7+σ

定义α1=min（超频时间倍数，2*超频电压倍数-0.25）

α2=1+ρ+（超频电压倍数-1）-（超频时间倍数-1）/2       （ρ为（0,1.0）之间的随机浮点数）

α3=min(α1,α2)

α4=max(α3,0)

理论输出算力=内部所有元件可提供的算力总和*α4。

实际输出算力，要对理论输出算力向下取整。

这里说明一下，如果不超频，则超频电压倍数为1，超频时间倍数为1，算力为内部所有元件可提供的算力总和。

另外，量子计算机机箱也会自然散热：

自然散热涉及以下方法：见自然散热.java

自然散热涉及两步：

第一步：首先遍历机箱内所有散热组件，热量改变量ΔHeatC=组件产热*当前热量/10000

第一步热量改变量为max(-当前热量，ΔHeatC向上取整）

第一步热量改变后：

如果heat>0

第二步热量改变量为-max(heat/1000,1)

如果heat<0

第二步热量改变量为-min(heat/1000,-1)

了解清楚原理之后，从RackComponent类生成对象的代码中，可以知道对应的某种元件的性质，注意：是先计算算力和热量改变量，再计算自然散热，注意计算的顺序。

判断某种设计是否可行有两种方式：

第一种：建立Heat(t+1)=f(Heat(t))的迭代公式，发现符合GuassSidel迭代法条件，从而判断系数矩阵是否严格对角占优或对称正定，能确定是否收敛。但是缺点是计算量大，而且仍然需要计算出稳定时的热量和最值，因为组件有允许的热量上限，要保证组件不会损毁。

第二种：直接建立方程，求稳定时的Heat值，这种计算较快，但是不能确定是否温度上升到高于Heat之后再降下来的情况，有可能这种情况导致了组件损坏。
